generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PREMIUM
  PRO
}

enum SkillCategory {
  BRICOLAGE_RENOVATION
  NUMERIQUE_TECH
  BIEN_ETRE_SERVICES
  CREATIF_ARTISANAT
  JARDIN_EXTERIEUR
}

enum ExchangeStatus {
  PENDING
  ACCEPTED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum TransactionType {
  CREDIT_EARNED
  CREDIT_SPENT
  CREDIT_DONATED
  CREDIT_RECEIVED
  PREMIUM_SUBSCRIPTION
  PRO_SUBSCRIPTION
}

model User {
  id                String          @id @default(cuid())
  email             String          @unique
  phone             String?
  passwordHash      String
  firstName         String
  lastName          String
  avatarUrl         String?
  bio               String?
  status            UserStatus      @default(ACTIVE)
  isVerified        Boolean         @default(false)
  verificationToken String?
  
  // Location
  address           String?
  city              String?
  postalCode        String?
  country           String          @default("FR")
  latitude          Float?
  longitude         Float?
  
  // Skills & Needs
  skills            Skill[]
  needs             Need[]
  
  // Exchanges
  exchangesAsHelper Exchange[]      @relation("ExchangeHelper")
  exchangesAsNeeder Exchange[]      @relation("ExchangeNeeder")
  
  // Ratings
  ratingsGiven      Rating[]
  ratingsReceived   Rating[]
  
  // Messages
  sentMessages      Message[]
  receivedMessages  Message[]
  
  // Credits
  credits           Credit          @relation(fields: [creditId], references: [id])
  creditId          String          @unique
  
  // Subscriptions
  subscriptionType  String?         @default("FREE")
  subscriptionEnd   DateTime?
  
  // Recommendations
  recommendations   Recommendation[]
  
  // Metadata
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  lastLogin         DateTime?
  
  @@index([latitude, longitude])
  @@index([city])
  @@index([status])
}

model Skill {
  id          String        @id @default(cuid())
  name        String
  category    SkillCategory
  description String?
  level       Int           @default(1) // 1-5
  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Need {
  id          String        @id @default(cuid())
  title       String
  description String?
  category    SkillCategory
  duration    Int           // in hours
  location    String?
  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  status      String        @default("OPEN")
  matches     Match[]
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  expiresAt   DateTime?
}

model Match {
  id          String        @id @default(cuid())
  needId      String
  skillId     String
  status      String        @default("PENDING") // PENDING, ACCEPTED, DECLINED
  score       Float         // Matching algorithm score
  
  need        Need          @relation(fields: [needId], references: [id], onDelete: Cascade)
  skill       Skill         @relation(fields: [skillId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime      @default(now())
}

model Exchange {
  id          String        @id @default(cuid())
  title       String
  description String?
  
  helperId    String
  neederId    String
  helper      User          @relation("ExchangeHelper", fields: [helperId], references: [id])
  needer      User          @relation("ExchangeNeeder", fields: [neederId], references: [id])
  
  skillId     String
  skill       Skill         @relation(fields: [skillId], references: [id])
  
  duration    Int           // hours
  status      ExchangeStatus @default(PENDING)
  
  scheduledAt DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  
  location    String?
  checklist   Json?         // JSON checklist
  
  chat        Chat?
  ratings     Rating[]
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Chat {
  id          String        @id @default(cuid())
  exchangeId  String        @unique
  exchange    Exchange      @relation(fields: [exchangeId], references: [id], onDelete: Cascade)
  
  messages    Message[]
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Message {
  id          String        @id @default(cuid())
  content     String
  senderId    String
  receiverId  String
  chatId      String?
  
  sender      User          @relation("SentMessages", fields: [senderId], references: [id])
  receiver    User          @relation("ReceivedMessages", fields: [receiverId], references: [id])
  chat        Chat?         @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  isRead      Boolean       @default(false)
  createdAt   DateTime      @default(now())
  
  @@index([chatId])
}

model Rating {
  id          String        @id @default(cuid())
  exchangeId  String
  raterId     String
  ratedId     String
  score       Int           // 1-5
  comment     String?
  
  exchange    Exchange      @relation(fields: [exchangeId], references: [id], onDelete: Cascade)
  rater       User          @relation("RatingsGiven", fields: [raterId], references: [id])
  rated       User          @relation("RatingsReceived", fields: [ratedId], references: [id])
  
  createdAt   DateTime      @default(now())
  
  @@unique([exchangeId, raterId])
}

model Credit {
  id          String        @id @default(cuid())
  userId      String        @unique
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  balance     Int           @default(0)
  
  transactions Transaction[]
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Transaction {
  id          String        @id @default(cuid())
  creditId    String
  amount      Int
  type        TransactionType
  description String?
  
  exchangeId  String?
  exchange    Exchange?     @relation(fields: [exchangeId], references: [id])
  
  metadata    Json?         // Additional data
  
  createdAt   DateTime      @default(now())
  
  credit      Credit        @relation(fields: [creditId], references: [id], onDelete: Cascade)
}

model Recommendation {
  id          String        @id @default(cuid())
  userId      String
  friendId    String
  message     String
  status      String        @default("PENDING")
  
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime      @default(now())
}

model Event {
  id          String        @id @default(cuid())
  title       String
  description String?
  type        String        // coffee_skills, workshop, etc.
  
  organizerId String
  organizer   User          @relation(fields: [organizerId], references: [id])
  
  location    String?
  address     String?
  latitude    Float?
  longitude   Float?
  
  startDate   DateTime
  endDate     DateTime
  maxAttendees Int?
  
  attendees   EventAttendance[]
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model EventAttendance {
  id          String        @id @default(cuid())
  eventId     String
  userId      String
  status      String        @default("REGISTERED") // REGISTERED, ATTENDED, CANCELLED
  
  event       Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime      @default(now())
  
  @@unique([eventId, userId])
}

model Notification {
  id          String        @id @default(cuid())
  userId      String
  type        String        // match, message, exchange_update, etc.
  title       String
  content     String
  data        Json?         // Additional data
  
  isRead      Boolean       @default(false)
  
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime      @default(now())
  
  @@index([userId, isRead])
}
